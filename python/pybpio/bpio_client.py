from cobs import cobs
import serial
import time 
import os
import sys
import threading
import queue

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import flatbuffers

# Generated by `flatc`.
import tooling.bpio.ConfigurationRequest as ConfigurationRequest
import tooling.bpio.ConfigurationResponse as ConfigurationResponse
import tooling.bpio.DataRequest as DataRequest
import tooling.bpio.DataResponse as DataResponse
import tooling.bpio.ModeConfiguration as ModeConfiguration
import tooling.bpio.RequestPacket as RequestPacket
import tooling.bpio.RequestPacketContents as RequestPacketContents
import tooling.bpio.ResponsePacket as ResponsePacket
import tooling.bpio.ResponsePacketContents as ResponsePacketContents
import tooling.bpio.StatusRequest as StatusRequest
import tooling.bpio.StatusRequestTypes as StatusRequestTypes
import tooling.bpio.StatusResponse as StatusResponse
#import tooling.bpio.ErrorResponse as ErrorResponse

class BPIOClient:
    def __init__(self, port, baudrate=3000000, timeout=2, debug=False, minimum_version=0):
        self.port = port
        self.baudrate = baudrate
        self.timeout = timeout
        self.debug = debug
        self.serial_port = None
        self.version_flatbuffers_major = 2
        self.minimum_version_flatbuffers_minor = minimum_version
        
        # Packet routing queues
        self._sync_queue = queue.Queue()   # For sync request/response
        self._async_queue = queue.Queue()  # For async DataResponse packets
        self._router_running = False
        self._router_thread = None
        self._pending_sync_request = False  # Flag to indicate we're waiting for a sync response
        
        # Open serial port
        try:
            self.serial_port = serial.Serial(self.port, self.baudrate, timeout=self.timeout)
            if self.debug:
                print(f"Opened serial port {self.port} at {self.baudrate} baud")
        except serial.SerialException as e:
            print(f"Failed to open serial port {self.port}: {e}")
            print("Make sure the serial port exists and is not in use by another application")
            raise
        except Exception as e:
            print(f"Error opening serial port: {e}")
            raise
        
        # Start the router thread
        self._start_router()
    
    def __enter__(self):
        """Context manager entry"""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit"""
        self.close()
    
    def close(self):
        """Close the serial port and stop router thread"""
        self._stop_router()
        if self.serial_port and self.serial_port.is_open:
            self.serial_port.close()
            if self.debug:
                print(f"Closed serial port {self.port}")
    
    def __del__(self):
        """Destructor - ensure port is closed"""
        self.close()
    
    def _start_router(self):
        """Start the packet router thread"""
        if self._router_running:
            return
        self._router_running = True
        self._router_thread = threading.Thread(target=self._router_loop, daemon=True)
        self._router_thread.start()
        if self.debug:
            print("Router thread started")
    
    def _stop_router(self):
        """Stop the packet router thread"""
        if not self._router_running:
            return
        self._router_running = False
        if self._router_thread:
            self._router_thread.join(timeout=1.0)
            self._router_thread = None
        if self.debug:
            print("Router thread stopped")
    
    def _router_loop(self):
        """Router thread: continuously reads packets and routes to appropriate queue"""
        resp_encoded = bytearray()
        
        while self._router_running:
            try:
                if not self.serial_port or not self.serial_port.is_open:
                    time.sleep(0.01)
                    continue
                
                # Check for available data
                available = self.serial_port.in_waiting
                if available > 0:
                    chunk = self.serial_port.read(available)
                    resp_encoded.extend(chunk)
                    
                    # Process all complete packets in buffer
                    while True:
                        delimiter_pos = resp_encoded.find(b'\x00')
                        if delimiter_pos == -1:
                            break  # No complete packet yet
                        
                        # Extract packet (excluding delimiter)
                        packet_encoded = bytes(resp_encoded[:delimiter_pos])
                        # Remove packet + delimiter from buffer
                        del resp_encoded[:delimiter_pos + 1]
                        
                        if not packet_encoded:
                            continue  # Empty packet, skip
                        
                        # COBS decode
                        try:
                            packet_data = cobs.decode(packet_encoded)
                        except cobs.DecodeError as e:
                            if self.debug:
                                print(f"Router: COBS decode error: {e}")
                            continue
                        
                        # Parse as ResponsePacket to determine routing
                        try:
                            resp_packet = ResponsePacket.ResponsePacket.GetRootAsResponsePacket(packet_data, 0)
                            contents_type = resp_packet.ContentsType()
                            
                            # Check if this is an async DataResponse
                            if contents_type == ResponsePacketContents.ResponsePacketContents.DataResponse:
                                data_resp = DataResponse.DataResponse()
                                data_resp.Init(resp_packet.Contents().Bytes, resp_packet.Contents().Pos)
                                
                                if data_resp.IsAsync():
                                    # Async packet -> async queue
                                    self._async_queue.put(packet_data)
                                    if self.debug:
                                        print(f"Router: async DataResponse -> async_queue")
                                else:
                                    # Sync response -> sync queue
                                    self._sync_queue.put(packet_data)
                                    if self.debug:
                                        print(f"Router: sync DataResponse -> sync_queue")
                            else:
                                # All other responses (Config, Status) -> sync queue
                                self._sync_queue.put(packet_data)
                                if self.debug:
                                    print(f"Router: {contents_type} -> sync_queue")
                                    
                        except Exception as e:
                            if self.debug:
                                print(f"Router: parse error: {e}")
                            # Put raw data in sync queue as fallback
                            self._sync_queue.put(packet_data)
                else:
                    # No data available, small sleep to prevent busy waiting
                    time.sleep(0.001)
                    
            except Exception as e:
                if self.debug:
                    print(f"Router error: {e}")
                time.sleep(0.01)
        
    def send_and_receive(self, data):
        """Send COBS-encoded data to serial port and receive COBS-encoded response via router"""
        if not self.serial_port or not self.serial_port.is_open:
            print("Serial port is not open")
            return None
        
        # Clear the sync queue of any stale responses
        while not self._sync_queue.empty():
            try:
                self._sync_queue.get_nowait()
            except queue.Empty:
                break
            
        try:           
            # Send COBS-encoded data followed by delimiter (0x00)
            packet = cobs.encode(data) + b'\x00'
            self.serial_port.write(packet)
            
            if self.debug:
                print(f"Sent {len(data)} bytes (original data)")
                print(f"Total bytes sent: {len(packet)} (COBS + delimiter)")

            # Wait for response from sync queue
            try:
                resp_data = self._sync_queue.get(timeout=self.timeout)
                if self.debug:
                    print(f"Received {len(resp_data)} bytes from sync_queue")
                return resp_data
            except queue.Empty:
                print("Timeout waiting for response")
                return None

        except serial.SerialException as e:
            print(f"Serial communication error: {e}")
        except Exception as e:
            print(f"Error: {e}")
        return None
    
    def _expected_response(self, request_type):
        """Get the expected response type for a given request type"""
        if request_type == RequestPacketContents.RequestPacketContents.ConfigurationRequest:
            return ResponsePacketContents.ResponsePacketContents.ConfigurationResponse
        elif request_type == RequestPacketContents.RequestPacketContents.DataRequest:
            return ResponsePacketContents.ResponsePacketContents.DataResponse
        elif request_type == RequestPacketContents.RequestPacketContents.StatusRequest:
            return ResponsePacketContents.ResponsePacketContents.StatusResponse
        else:
            return None

    def check_async_data(self, timeout=0):
        """Check for asynchronous DataResponse from the async queue.

        Returns a dict with keys:
          - 'is_async' (bool)
          - 'data_read' (list of ints)
          - 'error' (str or None)
        Returns None if no data available within timeout.
        """
        try:
            if timeout:
                resp_data = self._async_queue.get(timeout=timeout)
            else:
                resp_data = self._async_queue.get_nowait()
        except queue.Empty:
            return None

        try:
            resp_packet = ResponsePacket.ResponsePacket.GetRootAsResponsePacket(resp_data, 0)
        except Exception:
            return None

        # Parse DataResponse content
        if resp_packet.ContentsType() == ResponsePacketContents.ResponsePacketContents.DataResponse:
            data_resp = DataResponse.DataResponse()
            data_resp.Init(resp_packet.Contents().Bytes, resp_packet.Contents().Pos)
            data = []
            if data_resp.DataReadLength() > 0:
                try:
                    arr = data_resp.DataReadAsNumpy()
                    data = list(arr.tobytes())
                except Exception:
                    data = [data_resp.DataRead(i) for i in range(data_resp.DataReadLength())]

            return {
                'is_async': bool(data_resp.IsAsync()),
                'data_read': data,
                'error': data_resp.Error().decode('utf-8') if data_resp.Error() else None
            }

        return None

    def send_request(self, builder, request_contents_type, request_contents):
        """Send a request packet and return the response"""
        """Wrap contents in a RequestPacket"""
        RequestPacket.Start(builder)
        RequestPacket.AddVersionMajor(builder, self.version_flatbuffers_major)  # BPIO2
        RequestPacket.AddMinimumVersionMinor(builder, self.minimum_version_flatbuffers_minor) # Minimum flatbuffers version required
        RequestPacket.AddContentsType(builder, request_contents_type)
        RequestPacket.AddContents(builder, request_contents)
        final_packet = RequestPacket.End(builder)
        builder.Finish(final_packet)
        data = builder.Output()
    
        resp_data = self.send_and_receive(data)

        if not resp_data:
            return False

        # Decode response packet
        resp_packet = ResponsePacket.ResponsePacket.GetRootAsResponsePacket(resp_data, 0)     

        # Check for ErrorResponse
        if resp_packet.Error():
            print(f"Error: {resp_packet.Error().decode('utf-8')}")
            return False
        
        response_contents_type = resp_packet.ContentsType()
        if self.debug:
            print(f"ContentsType: {response_contents_type}")          
        
        expected_type = self._expected_response(request_contents_type)        
        if response_contents_type != expected_type:
            print(f"Unexpected response type: {response_contents_type}")
            return False

        return resp_packet
    
    def configuration_request(self, **kwargs):
        """Create a BPIO ConfigurationRequest packet"""
        builder = flatbuffers.Builder(1024)

        mode_string = None
        if 'mode' in kwargs:
            mode_string = builder.CreateString(kwargs['mode'])

        mode_config = None
        if 'mode_configuration' in kwargs:
            config_args = kwargs['mode_configuration']
            # Create a ModeConfiguration
            ModeConfiguration.Start(builder)
            if 'speed' in config_args:
                ModeConfiguration.AddSpeed(builder, config_args['speed'])
            else:
                ModeConfiguration.AddSpeed(builder, 20000)  # Default speed
            if 'data_bits' in config_args:
                ModeConfiguration.AddDataBits(builder, config_args['data_bits'])
            if 'parity' in config_args:
                ModeConfiguration.AddParity(builder, config_args['parity'])
            if 'stop_bits' in config_args:
                ModeConfiguration.AddStopBits(builder, config_args['stop_bits'])
            if 'flow_control' in config_args:
                ModeConfiguration.AddFlowControl(builder, config_args['flow_control'])
            if 'signal_inversion' in config_args:
                ModeConfiguration.AddSignalInversion(builder, config_args['signal_inversion'])
            if 'clock_stretch' in config_args:
                ModeConfiguration.AddClockStretch(builder, config_args['clock_stretch'])
            if 'clock_polarity' in config_args:
                ModeConfiguration.AddClockPolarity(builder, config_args['clock_polarity'])
            if 'clock_phase' in config_args:
                ModeConfiguration.AddClockPhase(builder, config_args['clock_phase'])
            if 'chip_select_idle' in config_args:
                ModeConfiguration.AddChipSelectIdle(builder, config_args['chip_select_idle'])
            if 'submode' in config_args:
                ModeConfiguration.AddSubmode(builder, config_args['submode'])
            if 'tx_modulation' in config_args:
                ModeConfiguration.AddTxModulation(builder, config_args['tx_modulation'])
            if 'rx_sensor' in config_args:
                ModeConfiguration.AddRxSensor(builder, config_args['rx_sensor'])
            mode_config = ModeConfiguration.End(builder)

        print_string = None
        if 'print_string' in kwargs:
            print_string = builder.CreateString(kwargs['print_string'])

        led_color_vector = None
        if 'led_color' in kwargs:
            led_colors = kwargs['led_color']
            ConfigurationRequest.StartLedColorVector(builder, len(led_colors))
            for color in reversed(led_colors):
                builder.PrependUint32(color)
            led_color_vector = builder.EndVector()    
        
        ConfigurationRequest.Start(builder)
        # Check if each key exists in kwargs and add it to the request
        if 'mode' in kwargs:
            ConfigurationRequest.AddMode(builder, mode_string)
        if 'mode_configuration' in kwargs:
            ConfigurationRequest.AddModeConfiguration(builder, mode_config)
        if 'mode_bitorder_msb' in kwargs:
            ConfigurationRequest.AddModeBitorderMsb(builder, kwargs['mode_bitorder_msb'])
        if 'mode_bitorder_lsb' in kwargs:
            ConfigurationRequest.AddModeBitorderLsb(builder, kwargs['mode_bitorder_lsb'])
        if 'psu_disable' in kwargs:
            ConfigurationRequest.AddPsuDisable(builder, kwargs['psu_disable'])
        if 'psu_enable' in kwargs:
            ConfigurationRequest.AddPsuEnable(builder, kwargs['psu_enable'])
        if 'psu_set_mv' in kwargs:
            ConfigurationRequest.AddPsuSetMv(builder, kwargs['psu_set_mv'])
        if 'psu_set_ma' in kwargs:
            ConfigurationRequest.AddPsuSetMa(builder, kwargs['psu_set_ma'])
        if 'pullup_disable' in kwargs:
            ConfigurationRequest.AddPullupDisable(builder, kwargs['pullup_disable'])
        if 'pullup_enable' in kwargs:
            ConfigurationRequest.AddPullupEnable(builder, kwargs['pullup_enable'])
        if 'io_direction_mask' in kwargs:
            ConfigurationRequest.AddIoDirectionMask(builder, kwargs['io_direction_mask'])
        if 'io_direction' in kwargs:
            ConfigurationRequest.AddIoDirection(builder, kwargs['io_direction'])
        if 'io_value_mask' in kwargs:
            ConfigurationRequest.AddIoValueMask(builder, kwargs['io_value_mask'])
        if 'io_value' in kwargs:
            ConfigurationRequest.AddIoValue(builder, kwargs['io_value'])
        if 'led_resume' in kwargs:  
            ConfigurationRequest.AddLedResume(builder, kwargs['led_resume'])    
        if 'led_color' in kwargs:       
            ConfigurationRequest.AddLedColor(builder, led_color_vector) 
        if 'print_string' in kwargs:
            ConfigurationRequest.AddPrintString(builder, print_string)
        if 'hardware_bootloader' in kwargs:
            ConfigurationRequest.AddHardwareBootloader(builder, kwargs['hardware_bootloader'])
        if 'hardware_reset' in kwargs:
            ConfigurationRequest.AddHardwareReset(builder, kwargs['hardware_reset'])
        if 'hardware_selftest' in kwargs:
            ConfigurationRequest.AddHardwareSelftest(builder, kwargs['hardware_selftest'])

        config_request = ConfigurationRequest.End(builder)
        resp_packet = self.send_request(builder, RequestPacketContents.RequestPacketContents.ConfigurationRequest, config_request)
        
        if not resp_packet:
            return False

        config_resp = ConfigurationResponse.ConfigurationResponse()
        config_resp.Init(resp_packet.Contents().Bytes, resp_packet.Contents().Pos)
        
        if config_resp.Error():
            print(f"Configuration error: {config_resp.Error().decode('utf-8')}")
            return False
        
        return True

    def status_request(self, **kwargs):
        """Create a BPIO StatusRequest packet"""        
        builder = flatbuffers.Builder(1024)

        # Define status type mapping for cleaner code
        STATUS_TYPES = {
            'version': StatusRequestTypes.StatusRequestTypes.Version,
            'mode': StatusRequestTypes.StatusRequestTypes.Mode,
            'pullup': StatusRequestTypes.StatusRequestTypes.Pullup,
            'psu': StatusRequestTypes.StatusRequestTypes.PSU,
            'adc': StatusRequestTypes.StatusRequestTypes.ADC,
            'io': StatusRequestTypes.StatusRequestTypes.IO,
            'disk': StatusRequestTypes.StatusRequestTypes.Disk,
            'led': StatusRequestTypes.StatusRequestTypes.LED,
        }

        # Collect requested status types
        requested_types = []
        if not kwargs:
            # No specific types requested, request all
            requested_types = [StatusRequestTypes.StatusRequestTypes.All]
        else:
            # Collect only the requested types that are True
            for key, status_type in STATUS_TYPES.items():
                if kwargs.get(key, False):
                    requested_types.append(status_type)

            # If user passed kwargs but none were true, request all
            if not requested_types:
                requested_types = [StatusRequestTypes.StatusRequestTypes.All]

        # Create the query vector (prepend in reverse order)
        StatusRequest.StartQueryVector(builder, len(requested_types))
        for status_type in reversed(requested_types):
            builder.PrependUint8(status_type)
        query_vector = builder.EndVector()

        # Create a StatusRequest
        StatusRequest.Start(builder)
        StatusRequest.AddQuery(builder, query_vector)
        status_request = StatusRequest.End(builder)
        resp_packet = self.send_request(builder, RequestPacketContents.RequestPacketContents.StatusRequest, status_request)
        
        if not resp_packet:
            return None
            
        status_resp = StatusResponse.StatusResponse()
        status_resp.Init(resp_packet.Contents().Bytes, resp_packet.Contents().Pos)

        # copy the status response into a dictionary (fields may be optional)
        status_dict = {
            'error': status_resp.Error().decode('utf-8') if status_resp.Error() else None,
            'version_flatbuffers_major': status_resp.VersionFlatbuffersMajor(),
            'version_flatbuffers_minor': status_resp.VersionFlatbuffersMinor(),
            'version_hardware_major': status_resp.VersionHardwareMajor(),
            'version_hardware_minor': status_resp.VersionHardwareMinor(),
            'version_firmware_major': status_resp.VersionFirmwareMajor(),
            'version_firmware_minor': status_resp.VersionFirmwareMinor(),
            'version_firmware_git_hash': status_resp.VersionFirmwareGitHash().decode('utf-8') if status_resp.VersionFirmwareGitHash() else None,
            'version_firmware_date': status_resp.VersionFirmwareDate().decode('utf-8') if status_resp.VersionFirmwareDate() else None,
            'modes_available': [status_resp.ModesAvailable(i).decode('utf-8') for i in range(status_resp.ModesAvailableLength())] if hasattr(status_resp, 'ModesAvailableLength') else [],
            'mode_current': status_resp.ModeCurrent().decode('utf-8') if status_resp.ModeCurrent() else None,
            'mode_pin_labels': [status_resp.ModePinLabels(i).decode('utf-8') for i in range(status_resp.ModePinLabelsLength())] if hasattr(status_resp, 'ModePinLabelsLength') else [],
            'mode_bitorder_msb': status_resp.ModeBitorderMsb() if hasattr(status_resp, 'ModeBitorderMsb') else None,
            'mode_max_packet_size': status_resp.ModeMaxPacketSize() if hasattr(status_resp, 'ModeMaxPacketSize') else None,
            'mode_max_write': status_resp.ModeMaxWrite() if hasattr(status_resp, 'ModeMaxWrite') else None,
            'mode_max_read': status_resp.ModeMaxRead() if hasattr(status_resp, 'ModeMaxRead') else None,
            'psu_enabled': status_resp.PsuEnabled() if hasattr(status_resp, 'PsuEnabled') else None,
            'psu_set_mv': status_resp.PsuSetMv() if hasattr(status_resp, 'PsuSetMv') else None,
            'psu_set_ma': status_resp.PsuSetMa() if hasattr(status_resp, 'PsuSetMa') else None,
            'psu_measured_mv': status_resp.PsuMeasuredMv() if hasattr(status_resp, 'PsuMeasuredMv') else None,
            'psu_measured_ma': status_resp.PsuMeasuredMa() if hasattr(status_resp, 'PsuMeasuredMa') else None,
            'psu_current_error': status_resp.PsuCurrentError() if hasattr(status_resp, 'PsuCurrentError') else None,
            'pullup_enabled': status_resp.PullupEnabled() if hasattr(status_resp, 'PullupEnabled') else None,
            'adc_mv': [status_resp.AdcMv(i) for i in range(status_resp.AdcMvLength())] if hasattr(status_resp, 'AdcMvLength') else [],
            'io_direction': status_resp.IoDirection() if hasattr(status_resp, 'IoDirection') else None,
            'io_value': status_resp.IoValue() if hasattr(status_resp, 'IoValue') else None,
            'disk_size_mb': status_resp.DiskSizeMb() if hasattr(status_resp, 'DiskSizeMb') else None,
            'disk_used_mb': status_resp.DiskUsedMb() if hasattr(status_resp, 'DiskUsedMb') else None,
            'led_count': status_resp.LedCount() if hasattr(status_resp, 'LedCount') else None
        }

        return status_dict
    
    def print_status_response(self, status_dict):
        """Parse and display status response from dictionary"""
        print("StatusResponse:")
        
        if status_dict.get('error'):
            print(f"  Error: {status_dict['error']}")
            return
        
        print(f"  Flatbuffers version: {status_dict['version_flatbuffers_major']}.{status_dict['version_flatbuffers_minor']}")
        print(f"  Hardware version: {status_dict['version_hardware_major']} REV{status_dict['version_hardware_minor']}")
        print(f"  Firmware version: {status_dict['version_firmware_major']}.{status_dict['version_firmware_minor']}")
        print(f"  Firmware git hash: {status_dict['version_firmware_git_hash']}")
        print(f"  Firmware date: {status_dict['version_firmware_date']}")

        if status_dict['modes_available']:
            print(f"  Available modes: {', '.join(status_dict['modes_available'])}")

        if status_dict['mode_current']:
            print(f"  Current mode: {status_dict['mode_current']}")

        print(f"  Mode bit order: {'MSB' if status_dict['mode_bitorder_msb'] else 'LSB'}")

        if status_dict['mode_pin_labels']:
            print(f"  Pin labels: {', '.join(status_dict['mode_pin_labels'])}")

        print(f"  Mode max packet size: {status_dict['mode_max_packet_size']} bytes")
        print(f"  Mode max write size: {status_dict['mode_max_write']} bytes")
        print(f"  Mode max read size: {status_dict['mode_max_read']} bytes")

        if status_dict['led_count']:
            print(f"  Number of LEDs: {status_dict['led_count']}")

        print(f"  Pull-up resistors enabled: {status_dict['pullup_enabled']}")
        print(f"  Power supply enabled: {status_dict['psu_enabled']}")
        print(f"  PSU set voltage: {status_dict['psu_set_mv']} mV")
        print(f"  PSU set current: {status_dict['psu_set_ma']} mA")
        print(f"  PSU measured voltage: {status_dict['psu_measured_mv']} mV")
        print(f"  PSU measured current: {status_dict['psu_measured_ma']} mA")        
        print(f"  PSU over current error: {'Yes' if status_dict['psu_current_error'] else 'No'}")

        if status_dict['adc_mv']:
            adc_values = [str(mv) for mv in status_dict['adc_mv']]
            print(f"  IO ADC values (mV): {', '.join(adc_values)}")

        # Print IO pin directions and values
        io_direction_byte = status_dict['io_direction']
        directions = []
        for i in range(8):
            bit_value = (io_direction_byte >> i) & 1
            direction = 'OUT' if bit_value else 'IN'
            directions.append(f"IO{i}:{direction}")
        print(f"  IO directions: {', '.join(directions)}")

        io_value_byte = status_dict['io_value']
        values = []
        for i in range(8):
            bit_value = (io_value_byte >> i) & 1
            value = 'HIGH' if bit_value else 'LOW'
            values.append(f"IO{i}:{value}")
        print(f"  IO values: {', '.join(values)}")

        print(f"  Disk size: {status_dict['disk_size_mb']} MB")
        print(f"  Disk space used: {status_dict['disk_used_mb']} MB")
    
    def show_status(self):
        """Get and print status information"""
        status_dict = self.status_request()
        if status_dict:
            self.print_status_response(status_dict)
        else:
            print("Failed to get status information.")

    def data_request(self, start_main=False, start_alt=False, data_write=None, bytes_read=0, stop_main=False, stop_alt=False):
        """Create a BPIO DataRequest packet"""
        builder = flatbuffers.Builder(1024)

        data_write_vector = None
        if data_write and len(data_write) > 0:
            data_write_vector = builder.CreateByteVector(bytes(data_write))

        # Create a DataRequest
        DataRequest.Start(builder)
        if start_main:
            DataRequest.AddStartMain(builder, True)
        if start_alt:
            DataRequest.AddStartAlt(builder, True)
        if data_write_vector:
            DataRequest.AddDataWrite(builder, data_write_vector)
        if bytes_read is not None:
            DataRequest.AddBytesRead(builder, bytes_read)
        if stop_main:
            DataRequest.AddStopMain(builder, True)
        if stop_alt:
            DataRequest.AddStopAlt(builder, True)

        data_request = DataRequest.End(builder)
        resp_packet = self.send_request(builder, RequestPacketContents.RequestPacketContents.DataRequest, data_request)
        
        if not resp_packet:
            return False
                    
        data_resp = DataResponse.DataResponse()
        data_resp.Init(resp_packet.Contents().Bytes, resp_packet.Contents().Pos)
        
        if data_resp.Error():
            if self.debug: print(f"Data request error: {data_resp.Error().decode('utf-8')}")
            return False

        # Return data read, if any
        if data_resp.DataReadLength() > 0:
            data_bytes = data_resp.DataReadAsNumpy()
            if self.debug:  print(f"Data read: {' '.join(f'{b:02x}' for b in data_bytes)}")
            return data_bytes.tobytes()
        else:
            return None
            
        return b''